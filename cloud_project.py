# -*- coding: utf-8 -*-
"""cloud_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iuE1wraTJzUBUL2MYhz2BU4zL03vbW59
"""

print("Cloud Project\n")

import numpy as np
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

def physical_resources():
    '''#computing capacity v
    #binary indicator pi
    #each application k
    #Total number of applications M'''
   
    M = 5
    pi = [0.8, 0.4, 0.2, 0.6, 0.4]
    v = [1,2,3,4,5]
    ptMax = 0
   
    for i in range(1,M):
        ptMax += v[i]*pi[i]
       
    return ptMax    
     
''' Task Queueing Model '''

def task_workload_queue(l,y,n=3,m=3):
  '''#application k
  #vehicle i
  #task workload queue Qi
  #task output queue Di
  #task workload queues M ie L1,L2,L3 etc   ''' 
  '''xi(t) represents how much task workload from the Qi(t) is locally
      processed by the vehicle i '''
  ''' zi(t) represents how much task workload from
      the Qi(t) is offloaded to the dedicated VM of the applica-
      tion k in the VM pool '''
  Qi = [90, 0, 0, 0]
  xi = [2.2, 0, 0, 0]
  Zi = [0.9, 0 , 0, 0]    
   
  for i in range(m):
      mid = 0
      for j in range(n):
          mid += l[i][j]*y[i][j]
      Qi[i+1] += Qi[i] - xi[i] - mid - Zi[i]

  return Qi

'''#p=CPU working power
#rho=Processing density
#x=task workload processed by vehicle i
#m=task workload queues
#E= vehicle energy consumption'''

def energy_vehicular(x,rho,p,s,m=3):
  E=1
  prod=1
  for k in range(m):
    prod *=pow(x,k)*rho

  E=(p*prod)/s
  return E

'''#z=task workload  offloaded to dedicated VM
#u=processed results uploaded to the post-analyses module in the edge cloud 
#En=cellular energy consumption
'''
def energy_cellular(z,u,d,p,m=3):
  En=1
  prod=1
  for k in range(m):
    prod *=pow(u,k)+pow(z,k)

  En=(p*prod)/s
  return En

'''#l=indicates whether vehicle will establish V2V link
#d=cellular uplink capacity
#s=available computing capacity '''

def scheduling_constraints(x,l,y,rho,z,u,n=3,m=3):
  s=0;
  prod2=1;
  for k in range(m):
    a=pow(x,k)
    prod=1
    for j in range(n):
      prod *=l[k][j]*pow(y[k][j],k)
    prod2*=prod
    s+=(a+prod)*rho

  d=1
  for k in range(m):
    d *=pow(u,k)+pow(z,k)

  for k in range(m):
    Q=pow(x,k)+prod2+pow(z,k)
    D=pow(u,k)

  return s,d,Q,D

Qii=[]
Qii.append(0)
Qii.extend(Qi)
    


x=3
l=[[0,0.2,1],[0.3,0.5,1],[1,0.9,0.8]]
y=[[1,2,1],[3,2,7],[5,4,2]]
rho=5
z=2
u=5
p=4

ptMax=physical_resources()
print("Maximum physical resources : ",ptMax)

Qi=task_workload_queue(l,y)
print("\nTask Workload Queue: ",Qi)

s,d,Q,D=scheduling_constraints(x,l,y,rho,z,u)
print("\nScheduling constraints: ",s,d,Q,D)

energy=energy_vehicular(x,rho,p,s)
print("\nVehicular energy consumption: ",energy)

energyn=energy_cellular(z,u,d,p)
print("\nCellular energy consumption: ",energyn)


y1 = Qii
x1 = [0,20,40,60,80]


 
# multiple line plot
plt.plot(x1,y1, markerfacecolor='blue', markersize=12, color='skyblue', linewidth=2)
plt.xlabel('time-slot')
plt.ylabel('workload')
plt.title('time-slot vs workload ')
plt.legend()